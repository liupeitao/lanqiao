本节将使用 test_linked_list 程序，首先确认在实验楼环境中已经执行过以下命令：

- 构建 test_linked_list 可执行程序

```
gcc -g -o test_linked_list linked_list.c test_linked_list.c
```

阅读源码，linked_list.h 和 linked_list.c 定义了线性数据结构链表，并且定义了一些对链表相关的操作。test_linked_list.c 中的 `main` 函数对链表进行删除等测试。

- 我们直接在实验楼环境中 Xfce 终端命令行运行该程序：

```
./test_linked_list
```

程序运行发生了段错误，由于没有任何输出信息，不能定位 bug 所在。如果不会调试的基本手段，就需要修改代码，加上很多 `printf` 语句，重新构建程序，尝试定位问题。





2.2 使用 GDB 调试程序



#### 2.2.1 调试的基本思路

- 使用 GDB 调试程序，启动待调试程序，先 run 一遍，查看挂在哪里。
- 在程序挂掉的地方设置断点，单步调试，找到 bug 所在。
- 由于程序中有很多函数调用关系，合理设置断点 结合 backtrace 快速定位问题。

#### 2.2.2 进行 debug

在本程序的调试中，请先按照上述 2.2.1 的思路进行调试，这里列出的调试过程仅供遇到困难时参考，如果有任何疑问，欢迎到 [实验楼问答](https://www.shiyanlou.com/questions) 中与同学们交流。

> 1. `$ gdb test_linked_list`
> 2. `list main`
> 3. `run`
> 4. `backtrace`
> 5. `break core_dump_test`
> 6. `list core_dump_test`
> 7. `next 2`
> 8. `info locals`
> 9. `step`
> 10. `backtrace full`
> 11. `next 4`
> 12. `print p`
> 13. `next`

debug 的步骤也可以按照自己习惯的顺序来。上述 debug 过程，在第 8 步就应该开始注意了 h 的值为 0，第 10 步、第 12 步都表明局部变量 p 的值为 0，最终 `p->next` **非法内存访问**。

此时你应该已经发现了 BUG 所处的位置，请自行修改，可以发布到实验楼的问答中与同学们交流。

C

#### 三、实验总结

#### 

本节实验通过调试一个有 BUG 的链表程序，实践上一节中学习的 GDB 调试技术。如果有兴趣，可以使用更多 GDB 强大的功能对链表程序进行调试：

> - test_linked_list 程序还可以进行 coredump 调试，有兴趣的可以自行尝试。
> - GDB 的一个缺点是源码和调试过程分开，导致经常需要 list 查看代码。*gdbtui* 是带图形界面的，有兴趣的可以自行尝试。