#### 实验内容

2022年4月8日15:50:02

---

此次实验的基本内容是：在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。

#### （1）`iam()`

第一个系统调用是 iam()，其原型为：

```c
int iam(const char * name);
```

完成的功能是将字符串参数 `name` 的内容拷贝到内核中保存下来。要求 `name` 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 `name` 的字符个数超过了 23，则返回 “-1”，并置 errno 为 EINVAL。

在 `kernal/who.c` 中实现此系统调用。

#### （2）`whoami()`

第二个系统调用是 whoami()，其原型为：

```c
int whoami(char* name, unsigned int size);
```

它将内核中由 `iam()` 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 `name` 越界访存（`name` 的大小由 `size` 说明）。返回值是拷贝的字符数。如果 `size` 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。

也是在 `kernal/who.c` 中实现。

#### （3）测试程序

运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。最终的运行结果是：

```bash
$ ./iam lizhijun

$ ./whoami

lizhijun
```



---

#### 实验报告

在实验报告中回答如下问题：

- 从 Linux 0.11 现在的机制看，它的系统调用最多能传递几个参数？你能想出办法来扩大这个限制吗？
- 用文字简要描述向 Linux 0.11 添加一个系统调用 foo() 的步骤。

---

#### 评分标准

- 将 testlab2.c（在 `/home/teacher` 目录下） 在修改过的 Linux 0.11 上编译运行，显示的结果即内核程序的得分。满分 50%
- 只要至少一个新增的系统调用被成功调用，并且能和用户空间交换参数，可得满分
- 将脚本 testlab2.sh（在 `/home/teacher` 目录下） 在修改过的 Linux 0.11 上运行，显示的结果即应用程序的得分。满分 30%
- 实验报告，20%

---

