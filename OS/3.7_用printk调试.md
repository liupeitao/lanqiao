#### 用 printk() 调试内核

2022年4月11日18:14:35

---

oslab 实验环境提供了基于 C 语言和汇编语言的两种调试手段。除此之外，适当地向屏幕输出一些程序运行状态的信息，也是一种很高效、便捷的调试方法，有时甚至是唯一的方法，被称为“printf 法”。

要知道到，printf() 是一个只能在用户模式下执行的函数，而系统调用是在内核模式中运行，所以 printf() 不可用，要用 printk()。

`printk()` 和 `printf()` 的接口和功能基本相同，只是代码上有一点点不同。printk() 需要特别处理一下 `fs` 寄存器，它是专用于用户模式的段寄存器。

看一看 printk 的代码（在 `kernel/printk.c` 中）就知道了：

```c
int printk(const char *fmt, ...)
{
//    ……
    __asm__("push %%fs\n\t"
            "push %%ds\n\t"
            "pop %%fs\n\t"
            "pushl %0\n\t"
            "pushl $buf\n\t"
            "pushl $0\n\t"
            "call tty_write\n\t"
            "addl $8,%%esp\n\t"
            "popl %0\n\t"
            "pop %%fs"
            ::"r" (i):"ax","cx","dx");
//    ……
}
```

显然，`printk()` 首先 `push %fs` 保存这个指向用户段的寄存器，在最后 `pop %fs` 将其恢复，printk() 的核心仍然是调用 `tty_write()`。查看 printf() 可以看到，它最终也要落实到这个函数上。



