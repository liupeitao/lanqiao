#### 完成 bootsect.s 的屏幕输出功能



> 代码中以 `!` 开头的行都是注释，实际在写代码时可以忽略。
>
> 实验中所有提到的修改，均是指相对于 linux-0.11 中的代码。

首先来看完成屏幕显示的关键代码，如下：

```asm
! 首先读入光标位置
    mov ah,#0x03
    xor bh,bh
    int 0x10

! 显示字符串 “Hello OS world, my name is LZJ”
! 要显示的字符串长度
    mov cx,#36
    mov bx,#0x0007
    mov bp,#msg1
! es:bp 是显示字符串的地址
! 相比与 linux-0.11 中的代码，需要增加对 es 的处理，因为原代码中在输出之前已经处理了 es
    mov ax,#0x07c0
    mov es,ax
    mov ax,#0x1301
    int 0x10

! 设置一个无限循环
inf_loop:
    jmp inf_loop
```

这里需要修改的是字符串长度，即用需要输出的字符串长度替换 `mov cx,#24` 中的 24。要注意：除了我们设置的字符串 msg1 之外，还有三个换行 + 回车，一共是 6 个字符。比如这里 `Hello OS world, my name is LZJ` 的长度是 30，加上 6 后是 36，所以代码应该修改为 `mov cx,#36`。

接下来就是修改输出的字符串了：

```asm
! msg1 处放置字符串
msg1:
! 换行 + 回车
    .byte   13,10
    .ascii  "Hello OS world, my name is LZJ"
! 两对换行 + 回车
    .byte   13,10,13,10

! boot_flag 必须在最后两个字节
.org 510
! 设置引导扇区标记 0xAA55
! 必须有它，才能引导
boot_flag:
    .word   0xAA55
```

将 `.org 508` 修改为 `.org 510`，是因为这里不需要 `root_dev: .word ROOT_DEV`，为了保证 `boot_flag` 一定在最后两个字节，所以要修改 `.org`。

完整的代码如下：

```asm
entry _start
_start:
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#36
    mov bx,#0x0007
    mov bp,#msg1
    mov ax,#0x07c0
    mov es,ax
    mov ax,#0x1301
    int 0x10
inf_loop:
    jmp inf_loop
msg1:
    .byte   13,10
    .ascii  "Hello OS world, my name is LZJ"
    .byte   13,10,13,10
.org 510
boot_flag:
    .word   0xAA55
```

接下来，将完成屏幕显示的代码在开发环境中编译，并将编译后的目标文件做成 Image 文件。



