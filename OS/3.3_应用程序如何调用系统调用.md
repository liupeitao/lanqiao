####  应用程序如何调用系统调用

2022年4月11日17:18:59

---

在通常情况下，调用系统调用和调用一个普通的自定义函数在代码上并没有什么区别，但调用后发生的事情有很大不同。

调用自定义函数是通过 call 指令直接跳转到该函数的地址，继续运行。

而调用系统调用，是调用系统库中为该系统调用编写的一个接口函数，叫 API（Application Programming Interface）。API 并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用，过程是：

- 把系统调用的编号存入 EAX；
- 把函数参数存入其它通用寄存器；
- 触发 0x80 号中断（int 0x80）。

linux-0.11 的 lib 目录下有一些已经实现的 API。Linus 编写它们的原因是在内核加载完毕后，会切换到用户模式下，做一些初始化工作，然后启动 shell。而用户模式下的很多工作需要依赖一些系统调用才能完成，因此在内核中实现了这些系统调用的 API。

> 后面的目录如果没有特殊说明，都是指在 `/home/shiyanlou/oslab/linux-0.11` 中。比如下面的 `lib/close.c`，是指 `/home/shiyanlou/oslab/linux-0.11/lib/close.c`。

我们不妨看看 lib/close.c，研究一下 `close()` 的 API：

```c
#define __LIBRARY__
#include <unistd.h>

_syscall1(int, close, int, fd)
```

其中 `_syscall1` 是一个宏，在 `include/unistd.h` 中定义。

```c
#define _syscall1(type,name,atype,a) \
type name(atype a) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
    : "=a" (__res) \
    : "0" (__NR_##name),"b" ((long)(a))); \
if (__res >= 0) \
    return (type) __res; \
errno = -__res; \
return -1; \
}
```

将 `_syscall1(int,close,int,fd)` 进行宏展开，可以得到：

```c
int close(int fd)
{
    long __res;
    __asm__ volatile ("int $0x80"
        : "=a" (__res)   
        : "0" (__NR_close),"b" ((long)(fd)));  // "0" means "a" -> eax 
    if (__res >= 0)      
        return (int) __res;
    errno = -__res; 
    return -1;
}
```

> C API 通常用宏定义 

**这就是 API 的定义。**它先将宏 `__NR_close` 存入 EAX，将参数 fd 存入 EBX，然后进行 0x80 中断调用。调用返回后，从 EAX 取出返回值，存入 `__res`，再通过对 `__res` 的判断决定传给 API 的调用者什么样的返回值。

其中 `__NR_close` 就是系统调用的编号，在 `include/unistd.h` 中定义：

```c
#define __NR_close    6
/*
所以添加系统调用时需要修改include/unistd.h文件，
使其包含__NR_whoami和__NR_iam。
*/
/*
而在应用程序中，要有：
*/

/* 有它，_syscall1 等才有效。详见unistd.h */
#define __LIBRARY__

/* 有它，编译器才能获知自定义的系统调用的编号 */
#include "unistd.h"

/* iam()在用户空间的接口函数 */
_syscall1(int, iam, const char*, name);

/* whoami()在用户空间的接口函数 */
_syscall2(int, whoami,char*,name,unsigned int,size);
```

关于unistd.h

> unistd.h是unix std的意思，是POSIX标准定义的unix类系统定义符号常量的头文件，
>
> 包含了许多UNIX系统服务的函数原型
>
> unistd.h在unix中类似于window中的windows.h!

在 0.11 环境下编译 C 程序，包含的头文件都在 `/usr/include` 目录下。

该目录下的 `unistd.h` 是标准头文件（它和 0.11 源码树中的 `unistd.h` 并不是同一个文件，虽然内容可能相同），没有 `__NR_whoami` 和 `__NR_iam` 两个宏，需要手工加上它们，也可以直接从修改过的 0.11 源码树中拷贝新的 unistd.h 过来。





