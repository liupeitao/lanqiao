1. 
   #号开头的行是注释行
2. #号不在开头就不是注释行
3. 注释行末尾加\ 则下一行也是注释, **<u>构成多行注释</u>**

下面是测试

```makefile
# 这是一个演示注释语法的makefile
all: test #关于依赖的注释
#    echo "Makefile for comment 1"   这里是注释，不是命令
    echo "Makefile for comment 2" 
# 这是一个关于test规则的 \
  多行注释
test:
# 没有反斜线\, #被当作注释的开始
    echo this is a # test rule1 
# 加上反斜线\, #被当作普通字符
    echo this is a \# test rule2 
    
```

执行结果

```bash
shiyanlou:makefile_sample/ $ make -f comment.mk       │~                                                   
echo this is a # test rule1                           │~                                                   
this is a                                             │~                                                   
echo this is a \# test rule2                          │~                                                   
this is a # test rule2                                │~                                                   
echo "Makefile for comment 2"                         │                                                   
Makefile for comment 2  
```

太乱? 看不出为啥测试的代码,执行的结果是这样? 那么去掉把makefile中的注释按照上面的规则去掉.

```makefile
all: test #关于依赖的注释
	echo "Makefile for comment 2" 
test:                   
	echo this is a # test rule1 
	echo this is a \# test rule2 
```

由此可以清晰的看出他的执行逻辑正如02makefile简介所介绍的. 

1. 先从上到下解析依赖

2. 从左到右, 在从下到上执行规则.

   

