Redis remote dictionary service 

key-value 数据库

支持持久化 ， 集群， 性能高， 多语言api接口， 支持多种数据类型



为什么性能高 

### 为什么Redis这么快

- `Redis` 是纯内存结构的，避免了磁盘 `I/O` 等耗时操作。
- `Redis` 命令处理的核心模块为单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。
- 采用了 `I/O` 多路复用机制，大大提升了并发效率。



### 为什么Redis 使用单线程来执行? 

1. 因为CPU不是Redis的瓶颈。网络和带宽才是

2. 使用多线程还会带来一个问题就是数据的安全性，所以多线程编程都会涉及到锁竞争，由此也会带来额外的开销。

> 我数学149， 英语40， 但是我还一直学习英语。

多线程一定比单线程快吗？  考虑线程的创建和销毁。

* `CPU` 密集型 
  * 多线程CPU效率可能不升反降。

* `IO` 密集型：

  

#### 什么是 IO 多路复用机制

`I/O` 指的是==网络 `I/O`==， 多路指的是多个 `TCP` 连接（如 `Socket`），复用指的是复用一个或多个线程。`I/O` 多路复用的核心原理就是不再由应用程序自己来监听连接，而是由服务器内核替应用程序监听。

```
在 Redis 中，其多路复用有多种实现，如：select，epoll，evport，kqueue 等。
```

点餐 - 客户端，厨房- 服务器，厨师-线程

- 阻塞 `IO`：张三去餐厅吃饭，点了一道菜，这时候他啥事也不干了，就是一直等，等到厨师炒好菜，他就把菜端走开始吃饭了。也就是在菜被炒好之前，张三被阻塞了，这就是 `BIO`（阻塞 `IO`），效率非常低下。
- 非阻塞 `IO`：张三去餐厅吃饭，点了一道菜，这时候张三他不会一直等，找了个位置坐下，刷刷抖音，打打电话，做点其它事，然后每隔一段时间就去厨房问一下自己的菜好了没有。这种就属于非阻塞 `IO`，这种方式虽然可以提高性能，但是如果有大量 `IO` 都来定期轮询，也会给服务器造成非常大的负担。
- 事件驱动机制：张三去餐厅吃饭，点了一道菜，这时候他找了个位置坐下来等，接下来厨房（服务器）有两种做法：
  - 厨房把菜做好了直接把菜端出去，但是端菜的人并不知道这道菜是谁的，于是就挨个询问顾客，这就是多路复用中的 `select` 模型，不过 `select` 模型最多只能监听 `1024` 个 `socket`（`poll` 模型解决了这个限制问题）。
  - 厨房把菜做好了直接把菜放在窗口上，大喊一声：“某某菜做好了，是谁的快过来拿。”这时候听到通知的顾客就会自己去拿，这就是多路复用中的 `epoll` 模型。

### Redis 中 I/O 多路复用的应用

`Redis` 服务器是一个事件驱动程序，服务器需要处理两类事件:

* 文件事件

  > `Redis` 服务器和客户端（或其它服务器）进行通信会产生相应的文件事件，然后服务器通过监听并处理这些事件来完成一系列的通信操作。

* 时间事件

  > `Redis` 内部的一些在给定时间之内需要进行的操作。

![01-8](https://doc.shiyanlou.com/courses/3368/1490584/02ac8989528e9ccfcf445f65c1fef8df-0)

`I/O` 多路复用程序虽然会同时监听多个 `Socket` 连接，但是其会将监听的 `Socket` 都放到一个==队列==里面，然后通过这个队列有序的、同步的将每个 `Socket` 对应的事件传送给文件事件分派器，再由文件事件分派器分派给对应的事件处理器进行处理，只有当一个 `Socket` 所对应的事件被处理完毕之后，`I/O` 多路复用程序才会继续向文件事件分派器传送下一个 `Socket` 所对应的事件，这也可以验证上面的结论，==处理客户端的命令请求是单线程的方式逐个处理，但是事件处理器内并不是只有一个线程==