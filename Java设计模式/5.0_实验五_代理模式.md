# 代理模式

为其他对象提供一种代理，以控制对这个对象的访问。

2022年10月09日15:59:07

2022年10月18日20:57:54

![代理模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20211025-proxy.svg)

---

代理模式（Proxy Pattern）一般是指一个对象为另一个对象提供一种代理，从而通过代理对象来控制非代理对象的访问，代理对象在客户端和目标对象之间起到中介作用。

代理模式属于结构型设计模式，可以分为静态代理和动态代理两种类型，而动态代理中又分为 JDK 动态代理和 CGLIB 代理两种。

静态代理模式



标准的静态代理模式需要定义一个接口，然后代理对象与被代理对象都需要实现标准接口，并重写标准接口中定义的方法，被代理对象本身需要实现真正的业务逻辑，而代理对象中一般是在调用被代理对象的前后新增一些其它逻辑处理。

### 静态代理示例

下面我们就以买火车票来举例说明，看看静态代理模式应该如何实现（这里我们需要新建一个 `proxy` 目录，相关类创建在 `proxy` 目录下）。

- 新建一个标准接口 `Travel.java`，这个接口中只定义了一个买火车票的方法。

```java
package proxy;

public interface Travel {
    void buyTrainticket();//买火车票
}
```

- 接下来定义一个被代理对象 `TravelPerson.java` 来实现 Travel 接口。

```java
package proxy;

public class TravelPerson implements Travel {
    @Override
    public void buyTrainticket() {//这个方法是真正实现买火车票的逻辑
        System.out.println("深圳到广州");
        System.out.println("早上9:00出发");
    }
}
```

- 然后我们需要新建一个代理类 `TravelAgency.java`，同样的也需要实现 Travel 接口。

```java
package proxy;

public class TravelAgency implements Travel {
    private TravelPerson travelPerson;//被代理对象

    public TravelAgency(TravelPerson travelPerson) {
        this.travelPerson = travelPerson;
    }

    @Override
    public void buyTrainticket(){
        before();
        this.travelPerson.buyTrainticket();//调用被代理对象的原方法
        after();

    }

    private void before() {
        System.out.println("付定金");
    }

    private void after() {
        System.out.println("付尾款");
    }
}
```

代理类里面持有了被代理对象，而其方法内会调用被代理对象的方法，并在前后增加了一些逻辑，其本身并不会改变被代理对象的原有逻辑。

- 最后我们新建一个测试类 `TestStaticProxy.java` 进行测试。

```java
package proxy;

public class TestStaticProxy {
    public static void main(String[] args) {
        TravelAgency travelAgency = new TravelAgency(new TravelPerson());
        travelAgency.buyTrainticket();
    }
}
```

现在我们需要验证一下结果，先执行 `javac proxy/*.java` 命令进行编译。然后再执行 `java proxy.TestStaticProxy` 命令运行测试类（大家一定要自己动手运行哦，只有自己实际去运行了才会更能体会其中的思想）。

![图8-1](https://doc.shiyanlou.com/courses/3031/1490584/520578d40b7a2d107e0769ad0d264b05-0)

这就是一个静态代理的实现方式，可以看到还是非常方便的，但是静态代理却有其局限性：

1. 代理对象需要显示的声明被代理对象，如果说后面想要修改代理对象，则需要修改源代码，不符合开闭原则。
2. 被代理对象如果新增了其它方法（接口新增了方法），那么代理对象也需要同步修改，不便于后期维护。

所以为了解决静态代理的局限性，就有了动态代理。



### 