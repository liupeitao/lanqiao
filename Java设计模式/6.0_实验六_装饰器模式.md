# 装饰器模式

2022年10月18日21:04:26

![装饰器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210420-decorator-1-decorator-decorator.svg)

---

装饰者模式（Decorator Pattern）是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案来扩展原有对象的功能，装饰者模式属于结构型模式。

#### 示例

下面我们以生活中的蛋糕举例说明，看看如何实现装饰者模式（这里我们需要新建一个 `decorator` 目录，相关类创建在 `decorator` 目录下）。

- 新建一个蛋糕的抽象类 `Cake.java`，这个类中定义了两个方法，一个获取蛋糕的基本信息，另一个获取蛋糕的价格。

```java
package decorator;

import java.math.BigDecimal;

public abstract class Cake {
    public abstract String getCakeMsg();//获取蛋糕的基本信息

    public abstract BigDecimal getPrice();//获取蛋糕的价格
}
```

- 接下来定义一个原生蛋糕（没有加其它比如水果之类的）`BaseCake.java`，并实现抽象蛋糕类 Cake。

```java
package decorator;

import java.math.BigDecimal;

public class BaseCake extends Cake {
    @Override
    public String getCakeMsg() {//获取蛋糕信息
        return "我是一个8英寸的普通蛋糕";
    }

    @Override
    public BigDecimal getPrice() {//获取蛋糕价格
        return new BigDecimal("68");
    }
}
```

- 现在我们还缺少一个装饰器，新建一个抽象装饰器 `CakeDecorator.java`，注意装饰器也需要实现抽象蛋糕类 Cake。

```java
package decorator;

import java.math.BigDecimal;

public abstract class CakeDecorator extends Cake{
    private Cake cake;

    public CakeDecorator(Cake cake) {
        this.cake = cake;
    }

    @Override
    public String getCakeMsg() {//获取蛋糕的信息
        return this.cake.getCakeMsg();//调用被装饰的对象原生方法
    }

    @Override
    public BigDecimal getPrice() {//获取蛋糕价格
        return this.cake.getPrice();//调用被装饰的对象原生方法
    }
}
```

可以看到，装饰器当中持有了蛋糕类 Cake，这个看起来有点像静态代理模式，但是请别着急，继续往后面看，这两种模式还是有本质区别的。

- 现在假如我们需要给蛋糕加点葡萄，那么就需要新建一个葡萄装饰器类 `CakeAddGrapeDecorator.java`，同时继承抽象装饰器类 CakeDecorator。

```java
package decorator;

import java.math.BigDecimal;

    public class CakeAddGrapeDecorator extends CakeDecorator {

    public CakeAddGrapeDecorator(Cake cake) {
        super(cake);
    }

    @Override
    public String getCakeMsg() {//获取蛋糕信息
        return super.getCakeMsg() + "+1个葡萄";//调用父类装饰器方法，再加上自定义的装饰(加1个葡萄)
    }

    @Override
    public BigDecimal getPrice() {//获取价格
        return super.getPrice().add(new BigDecimal("5"));//调用父类装饰器方法，再加上自定义的装饰(加5块钱)
    }
}
```

- 假如又需要加芒果，那么就再新建一个芒果装饰器 `CakeAddMangoDecorator.java`，同时也继承抽象装饰器类 CakeDecorator。

```java
package decorator;

import java.math.BigDecimal;

public class CakeAddMangoDecorator extends CakeDecorator {

    public CakeAddMangoDecorator(Cake cake) {
        super(cake);
    }

    @Override
    public String getCakeMsg() {//获取蛋糕信息
        return super.getCakeMsg() + "+1个芒果";//调用父类装饰器方法，再加上自定义的装饰(加1个芒果)
    }

    @Override
    public BigDecimal getPrice() {//获取价格
        return super.getPrice().add(new BigDecimal("10"));//调用父类装饰器方法，再加上自定义的装饰(加10块钱)
    }
}
```

- 最后我们新建一个测试类 `TestCakeDecorator.java`。

```java
package decorator;

public class TestCakeDecorator {
    public static void main(String[] args) {
        Cake cake = null;
        //普通蛋糕
        cake = new BaseCake();
        System.out.println(cake.getCakeMsg() + ",价格：" + cake.getPrice());
        //加一个芒果
        cake = new CakeAddMangoDecorator(cake);//芒果装饰器
        System.out.println(cake.getCakeMsg() + ",价格：" + cake.getPrice());
        //加一个葡萄
        cake = new CakeAddGrapeDecorator(cake);//葡萄装饰器
        System.out.println(cake.getCakeMsg() + ",价格：" + cake.getPrice());
        //再加一个芒果
        cake = new CakeAddMangoDecorator(cake);//芒果装饰器
        System.out.println(cake.getCakeMsg() + ",价格：" + cake.getPrice());
    }
}
```

执行 `javac decorator/*.java` 命令进行编译，然后再执行 `java decorator.TestCakeDecorator` 命令运行测试类（大家一定要自己动手运行哦，只有自己实际去运行了才会更能体会其中的思想）。

![图9-1](https://cdn.jsdelivr.net/gh/liupeitao/images/202210101549911.png)

可以看到，在使用装饰者模式之后，扩展之前的功能变得极为方便，可以根据现有的装饰器进行任意组合，而如果现有装饰器无法满足也可以新建装饰器来完成功能的扩展，依然十分方便。

#### 装饰者模式适用场景

1. 装饰者模式能将代理对象与真实被调用的目标对象分离，降低了系统的耦合度，所以扩展性比较好。
2. 动态的给一个对象添加功能时非常方便，而且还支持随时撤销这些添加的功能。

#### 装饰器模式优点

1. 装饰者比继承更加灵活，可以在不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。
2. 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。
3. 新增装饰者模式时，只需要新增对应的装饰者类，无需修改源码，符合开闭原则。

#### 装饰器模式缺点

1. 当装饰者非常多的时候，会引起类膨胀，使得系统更加复杂难以维护。



装饰者模式和代理模式都增强了原对象的功能，但是代理模式是通过重新生成代理类来实现功能增加，同一时间一般是一对一的关系，而装饰者模式是一对多关系，同一时间可以使用多个装饰器同时增强原有对象功能。