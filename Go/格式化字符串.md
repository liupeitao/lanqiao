格式化字符串

2022年3月25日14:19:15

---

Go 语言标准库中的 `fmt` 包提供了打印函数将数据以字符串形式输出到控制台，文件，其他满足 `io.Writer` 接口的值以及其他字符串。目前为止我们使用了 `fmt.Printf` 和 `fmt.Println`，对于前者的使用，就像 C 语言中的 `printf` 函数一样，我们可以提供一些格式化指令，让 Go 语言对输出的字符串进行格式化。同样的我们可以使用一些格式化修饰符，改变格式化指令的输出结果， 如左对齐等。常用的格式化指令如下：

| <u>格式化指令</u> | <u>含义</u>                                                  |
| ----------------- | ------------------------------------------------------------ |
| `%%`              | % 字面量C                                                    |
| `%b`              | 一个二进制整数，将一个整数格式化为二进制的表达方式           |
| `%c`              | 一个 Unicode 的字符                                          |
| `%d`              | 十进制数值                                                   |
| `%o`              | 八进制数值                                                   |
| `%x`              | 小写的十六进制数值                                           |
| `%XC`             | 大写的十六进制数值                                           |
| `%U`              | 一个 Unicode 表示法表示的整形码值，默认是 4 个数字字符       |
| `%s`              | 输出以原生的 UTF-8 字节表示的字符，如果 console 不支持 UTF-8 编码，则会输出乱码 |
| **`%t`**          | **以 true 或者 false 的方式输出布尔值** 😉                    |
| `%v`              | 使用默认格式输出值，或者使用类型的 String() 方法输出的自定义值，如果该方法存在的话 |
| %T                | 输出值的类型                                                 |

常用的格式化指令修饰符如下：

- `空白` 如果输出的数字为负，则在其前面加上一个减号 `-`。如果输出的是整数，则在前面加一个空格。使用 `%x` 或者 `%X` 格式化指令输出时，会在结果之间添加一个空格。例如 `fmt.Printf("% X", "实")` 输出 E5 AE 9E。

- ```
  #
  ```

  - `%#o` 输出以 `0` 开始的八进制数据。
  - `%#x` 输出以 `0x` 开始的十六进制数据。

- `+` 让格式化指令在数值前面输出 `+` 号或者 `-` 号，为字符串输出 ASCII 字符（非 ASCII 字符会被转义），为结构体输出其字段名。

- `-` 让格式化指令将值向左对齐（默认值为像右对齐）。

- `0` 让格式指令以数字 0 而非空白进行填充。

让我们练习一下，创建源文件 `fmt_t.go`，输入以下源码：

```go
package main

import (
    "fmt"
)

func main() {
    text := "\u5B9E\u9A8C\u697C"
    fmt.Printf("bool output:\n%t\n%t\n\n", true, false)
    fmt.Println("number output, origin value: 64")
    fmt.Printf("|%b|%8b|%-8b|%08b|% 8b|\n", 64, 64, 64, 64, 64)
    fmt.Printf("|%x|%8x|%-8x|%08X|% 8X|\n\n", 64, 64, 64, 64, 64)
    fmt.Println(`text output, origin value: \u5B9E\u9A8C\u697C`)
    fmt.Printf("content: %s\n", text)
    fmt.Printf("hex value: % X\nUnicode value: ", text)
    for _, char := range text {
        fmt.Printf("%U ", char)
    }
    fmt.Println()
    bytes := []byte(text)
    fmt.Printf("value of bytes: %s\n", bytes)
    fmt.Printf("hex value of bytes: % X\n", bytes)
    fmt.Printf("origin value of bytes: %v\n", bytes)

}
```

运行代码，输出如下：

```bash
$ go run fmt_t.go
bool output:
true
false

number output, origin value: 64
|1000000| 1000000|1000000 |01000000| 1000000|
|40|      40|40      |00000040|      40|

text output, origin value: \u5B9E\u9A8C\u697C
content: 实验楼
hex value: E5 AE 9E E9 AA 8C E6 A5 BC
Unicode value: U+5B9E U+9A8C U+697C
value of bytes: 实验楼
hex value of bytes: E5 AE 9E E9 AA 8C E6 A5 BC
origin value of bytes: [229 174 158 233 170 140 230 165 188]
```

代码一目了然，就不详细解释了。